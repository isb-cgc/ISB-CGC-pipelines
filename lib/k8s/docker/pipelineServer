#!/usr/bin/env python
import os
import re
import json
import webapp2
import httplib2
import argparse
import requests

from googleapiclient import discovery
from oauth2client.client import GoogleCredentials
from googleapiclient.errors import HttpError

from StringIO import StringIO
from paste import httpserver
from pipelines.routes import *
from pipelines.schema import PipelineSchema
from pipelines.builder import PipelineBuilder
from pipelines.config import PipelineConfig
from pipelines.service import PipelineService, PipelineServiceError
from pipelines.scheduler import PipelineScheduler
import pipelines.service.DataDisk
import pipelines.service.DataDiskError


CONFIG = PipelineConfig(path=os.environ["PIPELINES_CONFIG"])

SQLITE_READER_SERVICE_HOST = os.environ["SQLITE_READER_SERVICE_HOST"]
SQLITE_READER_SERVICE_PORT = os.environ["SQLITE_READER_SERVICE_PORT"]

SQLITE_WRITER_SERVICE_HOST = os.environ["SQLITE_WRITER_SERVICE_HOST"]
SQLITE_WRITER_SERVICE_PORT = os.environ["SQLITE_WRITER_SERVICE_PORT"]

CONFIG_WRITER_SERVICE_HOST = os.environ["CONFIG_WRITER_SERVICE_HOST"]


class Jobs(webapp2.RequestHandler):
	def get(self):
		kwargs = {}

		if re.match(JOBS_LIST_CREATE_EXP, self.request.path):
			try:
				jobsList = PipelineService.sendRequest(SQLITE_READER_SERVICE_HOST, SQLITE_READER_SERVICE_PORT, "/read/jobs?{query}".format(query=self.request.query_string), protocol="tcp")

			except ValueError as e:
				self.response.set_status(400, e)

			else:
				resp = {
					"jobsList": jobsList.json()["data"]
				}

				self.response.out = StringIO(json.dumps(resp))
				self.response.set_status(200)

		elif re.match(JOB_DESCRIBE_EXP, self.request.path):  # TODO: implement
			pass  # describe a particular job

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))

	def post(self):
		kwargs = json.loads(self.request.body)

		if re.match(JOBS_LIST_CREATE_EXP, self.request.path):
			# submits a job
			try:
				PipelineScheduler.submitPipeline(CONFIG, **kwargs)
			except:  # TODO: better exception handling in the utility classes
				self.response.set_status(400)

			else:
				self.response.set_status(201)

		elif re.match(JOB_EDIT_EXP, self.request.path):
			# edit job values given by **kwargs
			PipelineScheduler.editPipeline(CONFIG, **kwargs)

		elif re.match(JOB_RESTART_EXP, self.request.path):
			# restart a job
			PipelineScheduler.restartJobs(CONFIG, **kwargs)

		elif re.match(JOB_CANCEL_EXP, self.request.path):
			# stop/cancel a job
			PipelineScheduler.stopPipeline(CONFIG, **kwargs)

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))


class Config(webapp2.RequestHandler):
	def post(self):
		data = json.load(self.request.body)
		resp = None
		status = None

		if re.match(CONFIG_VIEW_INIT_EXP, self.request.path):
			pass  # initialize the config file

		elif re.match(CONFIG_EDIT_EXP, self.request.path):
			pass  # edit the config file

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))

		if resp is not None:
			self.response.out = StringIO(json.dumps(resp))

		self.response.set_status(status)

	def get(self):
		data = json.load(self.request.body)
		resp = None
		status = None

		if re.match(CONFIG_VIEW_INIT_EXP, self.request.path):
			pass  # package up the config file contents and return

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))

		if resp is not None:
			self.response.out = StringIO(json.dumps(resp))

		self.response.set_status(status)


class DataDisk(webapp2.RequestHandler):
	def post(self):
		data = json.load(self.request.body)
		resp = None
		status = None

		if re.match(DATADISKS_LIST_CREATE_EXP, self.request.path):
			# request format:
			# {
			#   "diskName": <disk-name>,
			#   "diskType": <disk-type>|None,
			#   "diskSize": <disk-size>,
			#   "zone": <zone>|None
			# }
			#

			try:
				pipelines.service.disks.DataDisk.create(CONFIG, **data)

			except pipelines.service.disks.DataDiskError as e:
				resp = {
					"msg": e
				}
				status = 400
			else:
				status = 204

		elif re.match(DATADISK_DESCRIBE_DELETE_EXP, self.request.path):
			# request format:
			# {
			#   "disk_name": <disk-name>,
			#   "disk_type": <disk-type>|None,
			#   "disk_size": <disk-size>,
			#   "disk_zone": <zone>|None,
			#   "job_id": <job-id>
			# }
			#
			pipelines.service.DataDisk.delete()  # TODO: args

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))

		if resp is not None:
			self.response.out = StringIO(json.dumps(resp))

		self.response.set_status(status)

	def get(self):
		data = json.loads(self.request.body)
		resp = None
		status = None

		if re.match(DATADISKS_LIST_CREATE_EXP, self.request.path):
			results = PipelineService.sendRequest(SQLITE_READER_SERVICE_HOST, SQLITE_READER_SERVICE_PORT, "")  # TODO: args

		elif re.match(DATADISK_DESCRIBE_DELETE_EXP, self.request.path):
			pass  # describe the data disk(s)

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))

		if resp is not None:
			self.response.out = StringIO(json.dumps(resp))

		self.response.set_status(status)


class Log(webapp2.RequestHandler):
	def get(self):
		data = json.loads(self.request.body)
		resp = None
		status = None

		if re.match(LOG_STDOUT_EXP, self.request.path):
			pass  # get the stdout log path and return

		elif re.match(LOG_STDERR_EXP, self.request.path):
			pass  # get the stderr log path and return


		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))

		if resp is not None:
			self.response.out = StringIO(json.dumps(resp))

		self.response.set_status(status)


app = webapp2.WSGIApplication([
	(JOBS_LIST_CREATE_EXP, Jobs),
	(JOB_DESCRIBE_EXP, Jobs),
	(JOB_EDIT_EXP, Jobs),
	(JOB_CANCEL_EXP, Jobs),
	(JOB_RESTART_EXP, Jobs),
	(CONFIG_VIEW_INIT_EXP, Config),
	(CONFIG_EDIT_EXP, Config),
	(DATADISKS_LIST_CREATE_EXP, DataDisk),
	(DATADISK_DESCRIBE_DELETE_EXP, DataDisk),
	(LOG_STDOUT_EXP, Log),
	(LOG_STDERR_EXP, Log),
], debug=True)


def main(host, port):
	httpserver.serve(app, host=host, port=port)


if __name__ == "__main__":
	parser = argparse.ArgumentParser()
	parser.add_argument("--host", required=False, default="0.0.0.0")
	parser.add_argument("--port", required=False, default=80)
	args = parser.parse_args()
	main(args.host, args.port)
