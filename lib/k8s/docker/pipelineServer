#!/usr/bin/env python
import os
import re
import json
import webapp2
import argparse
import requests

from StringIO import StringIO
from paste import httpserver
from pipelines.routes import *
from pipelines.schema import PipelineSchema
from pipelines.builder import PipelineBuilder
from pipelines.config import PipelineConfig
from pipelines.db import PipelineDatabase
from pipelines.service import PipelineService
from pipelines.scheduler import PipelineScheduler


CONFIG = PipelineConfig(path=os.environ["PIPELINES_CONFIG"])

SQLITE_READER_SERVICE_HOST = os.environ["SQLITE_READER_SERVICE_HOST"]
SQLITE_READER_SERVICE_PORT = os.environ["SQLITE_READER_SERVICE_PORT"]

SQLITE_WRITER_SERVICE_HOST = os.environ["SQLITE_WRITER_SERVICE_HOST"]
SQLITE_WRITER_SERVICE_PORT = os.environ["SQLITE_WRITER_SERVICE_PORT"]

CONFIG_WRITER_SERVICE_HOST = os.environ["CONFIG_WRITER_SERVICE_HOST"]


class Jobs(webapp2.RequestHandler):
	def get(self):
		kwargs = {}

		if re.match(JOBS_LIST_CREATE_EXP, self.request.path):
			try:
				jobsList = PipelineService.sendRequest(SQLITE_READER_SERVICE_HOST, SQLITE_READER_SERVICE_PORT, "/read/jobs?{query}".format(query=self.request.query_string), protocol="tcp")

			except ValueError as e:
				self.response.set_status(400, e)

			else:
				resp = {
					"jobsList": jobsList.json()["data"]
				}

				self.response.out = StringIO(json.dumps(resp))
				self.response.set_status(200)

		elif re.match(JOB_DESCRIBE_EXP, self.request.path):  # TODO: implement
			pass  # describe a particular job

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))

	def post(self):
		kwargs = json.loads(self.request.body)

		if re.match(JOBS_LIST_CREATE_EXP, self.request.path):
			# submits a job
			try:
				PipelineScheduler.submitPipeline(CONFIG, **kwargs)
			except:  # TODO: better exception handling in the utility classes
				self.response.set_status(400)

			else:
				self.response.set_status(201)

		elif re.match(JOB_EDIT_EXP, self.request.path):
			# edit job values given by **kwargs
			PipelineScheduler.editPipeline(CONFIG, **kwargs)

		elif re.match(JOB_RESTART_EXP, self.request.path):
			# restart a job
			PipelineScheduler.restartJobs(CONFIG, **kwargs)

		elif re.match(JOB_CANCEL_EXP, self.request.path):
			# stop/cancel a job
			PipelineScheduler.stopPipeline(CONFIG, **kwargs)

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))


class Config(webapp2.RequestHandler):
	def post(self):
		if re.match(CONFIG_VIEW_INIT_EXP, self.request.path):
			pass  # initialize the config file

		elif re.match(CONFIG_EDIT_EXP, self.request.path):
			pass  # edit the config file

		else:
			pass  # return "bad request"

	def get(self):
		if re.match(CONFIG_VIEW_INIT_EXP, self.request.path):
			pass  # package up the config file contents and return

		else:
			pass  # return "bad request"


class DataDisk(webapp2.RequestHandler):
	def post(self):
		if re.match(DATADISKS_LIST_CREATE_EXP, self.request.path):
			pass  # create the data disk(s)

		elif re.match(DATADISK_DESCRIBE_DELETE_EXP, self.request.path):
			pass  # delete the data disk(s)

		else:
			pass  # return "bad request"

	def get(self):
		if re.match(DATADISKS_LIST_CREATE_EXP, self.request.path):
			pass  # list the data disks given any filters

		elif re.match(DATADISK_DESCRIBE_DELETE_EXP, self.request.path):
			pass  # describe the data disk(s)

		else:
			pass  # return "bad request"


class Log(webapp2.RequestHandler):
	def get(self):
		if re.match(LOG_STDOUT_EXP, self.request.path):
			pass  # get the stdout log path and return

		elif re.match(LOG_STDERR_EXP, self.request.path):
			pass  # get the stderr log path and return

		else:
			pass  # return "bad request"


app = webapp2.WSGIApplication([
	(JOBS_LIST_CREATE_EXP, Jobs),
	(JOB_DESCRIBE_EXP, Jobs),
	(JOB_EDIT_EXP, Jobs),
	(JOB_CANCEL_EXP, Jobs),
	(JOB_RESTART_EXP, Jobs),
	(CONFIG_VIEW_INIT_EXP, Config),
	(CONFIG_EDIT_EXP, Config),
	(DATADISKS_LIST_CREATE_EXP, DataDisk),
	(DATADISK_DESCRIBE_DELETE_EXP, DataDisk),
	(LOG_STDOUT_EXP, Log),
	(LOG_STDERR_EXP, Log),
], debug=True)


def main(host, port):
	httpserver.serve(app, host=host, port=port)


if __name__ == "__main__":
	parser = argparse.ArgumentParser()
	parser.add_argument("--host", required=False, default="0.0.0.0")
	parser.add_argument("--port", required=False, default=80)
	args = parser.parse_args()
	main(args.host, args.port)
