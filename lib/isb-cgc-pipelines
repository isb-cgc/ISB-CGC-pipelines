#!/usr/bin/env python
import os
import json
import requests
import argparse
import httplib2
from googleapiclient import discovery
from oauth2client.client import GoogleCredentials
from pipelines.routes import *
from pipelines.paths import *
from pipelines.config import PipelineConfig
from pipelines.service import PipelineService
from pipelines.scheduler import PipelineScheduler


if __name__ == "__main__":
	parser = argparse.ArgumentParser(description="")
	subparsers = parser.add_subparsers(dest="subcommand")

	jobs = subparsers.add_parser("jobs")
	jobs.add_argument("jobsOperation", choices=["describe", "list", "submit", "edit", "restart", "cancel"])

	dataDisks = subparsers.add_parser("data-disks")
	dataDisks.add_argument("dataDiskOperation", choices=["create", "delete", "list", "describe"])

	config = subparsers.add_parser("config")
	config.add_argument("configOperation", choices=["init", "update", "view"])

	logs = subparsers.add_parser("logs")
	logs.add_argument("logsOperation", choices=["display"])

	scheduler = subparsers.add_parser("scheduler")
	scheduler.add_argument("schedulerOperation", choices=["start", "stop"])
	
	args, unknown = parser.parse_known_args()

	if args.subcommand == "jobs":
		parser = argparse.ArgumentParser()

		if args.jobsOperation == "submit":
			parser.add_argument("--pipeline", required=True)
			parser.add_argument("--imageName", required=True)
			submitGrp = parser.add_mutually_exclusive_group(required=True)
			submitGrp.add_argument("--scriptUrl")
			submitGrp.add_argument("--cmd")
			parser.add_argument("--logsPath", required=True)
			parser.add_argument("--diskSize", required=False, default=None)
			parser.add_argument("--diskType", required=False, default=None)
			parser.add_argument("--cores", required=False, default=1)
			parser.add_argument("--mem", required=False, default=1)
			parser.add_argument("--inputs", required=False, default=None)
			parser.add_argument("--outputs", required=False, default=None)
			parser.add_argument("--env", required=False, default=None)
			parser.add_argument("--tag", required=False, default=None)
			parser.add_argument("--preemptible", action="store_true", default=False)
			parser.add_argument("--syncOutputs", required=False, default=None)

			args = parser.parse_args(args=unknown)
			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, JOBS_LIST_CREATE_EXP, data=vars(args))
			print resp.get("msg")

		elif args.jobsOperation == "edit":
			parser.add_argument("--pipeline")
			parser.add_argument("--logsPath")
			parser.add_argument("--imageName")
			editGrp = parser.add_mutually_exclusive_group()
			editGrp.add_argument("--scriptUrl")
			editGrp.add_argument("--cmd")
			parser.add_argument("--cores")
			parser.add_argument("--mem")
			parser.add_argument("--diskSize")
			parser.add_argument("--diskType")
			parser.add_argument("--inputs")
			parser.add_argument("--outputs")
			parser.add_argument("--env")
			parser.add_argument("--preemptible")
			parser.add_argument("--syncOutputs")
			parser.add_argument("jobId", required=True)

			args = parser.parse_args(args=unknown)
			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, JOB_EDIT_EXP, data=vars(args))
			print resp.get("msg")

		elif args.jobsOperation == "list":
			parser.add_argument("--pipeline", required=False, default=None)
			parser.add_argument("--tag", required=False, default=None)
			parser.add_argument("--status", choices=["running", "waiting", "succeeded", "failed", "error", "preempted"], required=False, default=None)
			parser.add_argument("--createTimeAfter", required=False, default=None)
			parser.add_argument("--limit", required=False, default=None)

			args = parser.parse_args(args=unknown)

			uri = "{route}?{query}"
			query = ["select={select}".format(select=','.join(["job_id", "operation_id", "pipeline_name", "tag", "current_status", "create_time", "preemptions"]))]

			if args.pipeline:
				query.append("pipeline={p}".format(p=args.pipeline))

			elif args.tag:
				query.append("tag={t}".format(t=args.tag))

			elif args.status:
				query.append("status={s}".format(s=args.status))

			elif args.createTimeAfter:
				query.append("createTimeAfter={c}".format(c=args.createTimeAfter))

			elif args.limit:
				query.append("limit={l}".format(l=args.limit))

			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, uri.format(route=JOBS_LIST_CREATE_EXP, query='&'.join(query)))
			jobs = json.loads(resp.get("jobsList"))

			for j in jobs:
				print j

		elif args.jobsOperation == "describe":
			parser.add_argument("jobId")

			args = parser.parse_args(args=unknown)
			query = "jobId={j}".format(j=args.jobId)
			uri = "{route}?{query}".format(route=JOB_DESCRIBE_EXP, query=query)
			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, uri)

			# TODO: pretty print response

		elif args.jobsOperation == "cancel":  # TODO: make sure that the sql expression ORs these values to get the result
			parser.add_argument("--jobId")
			parser.add_argument("--pipeline")
			parser.add_argument("--tag")

			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, JOB_CANCEL_EXP, data=vars(args))
			print resp.get("msg")

		elif args.jobsOperation == "restart":
			restartGrp = parser.add_mutually_exclusive_group()
			restartGrp.add_argument("--jobId")
			restartGrp.add_argument("--tag")
			restartGrp.add_argument("--preempted", action="store_true")

			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, JOB_RESTART_EXP, data=vars(args))
			print resp.get("msg")

	elif args.subcommand == "data-disks":
		parser = argparse.ArgumentParser()

		if args.dataDisksOperation == "create":
			parser.add_argument("--inputs", required=True)
			parser.add_argument("--zone", required=False)
			parser.add_argument("diskName")

			args = parser.parse_args(args=unknown)

			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, DATADISKS_LIST_CREATE_EXP, data=vars(args))
			print resp.get("msg")

		elif args.dataDisksOperation == "delete":
			parser.add_argument("--zone", required=False)
			parser.add_argument("diskName")

			args = parser.parse_args(args=unknown)

			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, DATADISK_DESCRIBE_DELETE_EXP, data=vars(args))
			print resp.get("msg")

		elif args.dataDisksOperation == "list":
			parser.add_argument("--zone", required=False)
			parser.add_argument("diskName")

			args = parser.parse_args(args=unknown)
			query = ["diskName={d}".format(d=args.diskName)]

			if args.zone:
				query.append("zone={z}".format(z=args.zone))

			uri = "{route}?{query}".format(route=DATADISKS_LIST_CREATE_EXP, query='&'.join(query))
			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, uri)

			# TODO: pretty print response

		elif args.dataDisksOperation == "describe":
			parser.add_argument("diskName")

			args = parser.parse_args(args=unknown)
			query = "diskName={d}".format(d=args.diskName)
			uri = "{route}?{query}".format(route=DATADISK_DESCRIBE_DELETE_EXP, query=query)
			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, uri)

			# TODO: pretty print response

	elif args.subcommand == "logs":
		parser = argparse.ArgumentParser()

		if args.logsOperation == "display":
			parser.add_argument("--stderr", action="store_true")
			parser.add_argument("--stdout", action="store_true", default=True)
			parser.add_argument("jobId")

			args = parser.parse_args(args=unknown)
			query = "jobId={j}".format(jobId=args.jobId)

			if args.stdout:
				uri = "{route}?{query}".format(route=LOG_STDOUT_EXP, query=query)
				resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, uri)

				# TODO: get the logs path from the response and use `gsutil cat ... ` to print

			elif args.stderr:
				uri = "{route}?{query}".format(route=LOG_STDERR_EXP, query=query)
				resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, uri)

				# TODO: get the logs path from the response and use `gsutil cat ... ` to print

	elif args.subcommand == "scheduler":  # TODO: check to see if config file exists -- if so, check the configuration for enabled extensions; otherwise report an error if the scheduler subcommand is used
		config = PipelineConfig(CLIENT_CONFIG_PATH)
		user = os.environ["USER"]

		if args.schedulerOperation == "stop":
			PipelineScheduler.stopScheduler()
		elif args.schedulerOperation == "start":
			PipelineScheduler.startScheduler(config, user)
		else:
			print "ERROR: unrecognized option {o}".format(o=args.startOrStop)
			exit(-1)

	elif args.subcommand == "config":
		parser = argparse.ArgumentParser()

		if args.configOperation == "init":
			# TODO: prompt for user input to construct request
			req = {}
			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, CONFIG_VIEW_INIT_EXP, data=req)
			print resp.get("msg")

		elif args.configOperation == "update":
			parser.add_argument("--projectId")
			parser.add_argument("--zones")
			parser.add_argument("--serviceAccount")
			parser.add_argument("--autorestartPreempted")
			# TODO: possibly add more args

			args = parser.parse_args(args=unknown)

			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, CONFIG_EDIT_EXP, data=vars(args))
			print resp.get("msg")

				# TODO: move code below to another location
				#config = PipelineConfig(CLIENT_CONFIG_PATH)
				#section, option = args.parameter.split('/')
				#try:
				#	config.update(section, option, value)
				#except ValueError as e:
				#	print "ERROR: couldn't update the configuration : {reason}".format(reason=e)
				#	exit(-1)

		elif args.configOperation == "view":
			resp = PipelineService.sendRequest(config.service_endpoint, config.service_port, CONFIG_VIEW_INIT_EXP)

			# TODO: pretty print response
