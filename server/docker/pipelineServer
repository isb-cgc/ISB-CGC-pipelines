#!/usr/bin/env python
import os
import re
import json
import webapp2
from StringIO import StringIO
from paste import httpserver
from pipelines.routes import *
from pipelines.utils import PipelineSchema, PipelineBuilder, PipelinesConfig, PipelineDbUtils, PipelineServiceUtils, PipelineSchedulerUtils


CONFIG = PipelinesConfig(path=os.environ["PIPELINES_CONFIG"])


class Jobs(webapp2.RequestHandler):
	def get(self):
		kwargs = {}

		if re.match(JOBS_LIST_CREATE_EXP, self.request.path):
			kwargs["pipeline"] = self.request.get("pipeline")
			kwargs["tag"] = self.request.get("tag")
			kwargs["status"] = self.request.get("status")
			kwargs["createTimeAfter"] = self.request.get("createTimeAfter")
			kwargs["limit"] = self.request.get("limit")

			try:
				jobsList = PipelineSchedulerUtils.getJobsList(CONFIG, **kwargs)

			except ValueError as e:
				self.response.set_status(400, e)

			else:
				resp = {
					"jobsList": jobsList
				}

				self.response.out = StringIO(json.dumps(resp))
				self.response.set_status(200)

		elif re.match(JOB_DESCRIBE_EXP, self.request.path):  # TODO: implement
			pass  # describe a particular job

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))

	def post(self):
		kwargs = json.loads(self.request.body)

		if re.match(JOBS_LIST_CREATE_EXP, self.request.path):
			# submits a job
			try:
				PipelineSchedulerUtils.submitPipeline(CONFIG, **kwargs)
			except:  # TODO: better exception handling in the utility classes
				self.response.set_status(400)

			else:
				self.response.set_status(201)

		elif re.match(JOB_EDIT_EXP, self.request.path):
			# edit job values given by **kwargs
			PipelineSchedulerUtils.editPipeline(CONFIG, **kwargs)

		elif re.match(JOB_RESTART_EXP, self.request.path):
			# restart a job
			PipelineSchedulerUtils.restartJobs(CONFIG, **kwargs)

		elif re.match(JOB_CANCEL_EXP, self.request.path):
			# stop/cancel a job
			PipelineSchedulerUtils.stopPipeline(CONFIG, **kwargs)

		else:
			self.response.set_status(404, "Resource {r} not found".format(r=self.request.path))


class Config(webapp2.RequestHandler):
	def post(self):
		if re.match(CONFIG_VIEW_INIT_EXP, self.request.path):
			pass  # initialize the config file

		elif re.match(CONFIG_EDIT_EXP, self.request.path):
			pass  # edit the config file

		else:
			pass  # return "bad request"

	def get(self):
		if re.match(CONFIG_VIEW_INIT_EXP, self.request.path):
			pass  # package up the config file contents and return

		else:
			pass  # return "bad request"


class DataDisk(webapp2.RequestHandler):
	def post(self):
		if re.match(DATADISKS_LIST_CREATE_EXP, self.request.path):
			pass  # create the data disk(s)

		elif re.match(DATADISK_DESCRIBE_DELETE_EXP, self.request.path):
			pass  # delete the data disk(s)

		else:
			pass  # return "bad request"

	def get(self):
		if re.match(DATADISKS_LIST_CREATE_EXP, self.request.path):
			pass  # list the data disks given any filters

		elif re.match(DATADISK_DESCRIBE_DELETE_EXP, self.request.path):
			pass  # describe the data disk(s)

		else:
			pass  # return "bad request"


class Log(webapp2.RequestHandler):
	def get(self):
		if re.match(LOG_STDOUT_EXP, self.request.path):
			pass  # get the stdout log path and return

		elif re.match(LOG_STDERR_EXP, self.request.path):
			pass  # get the stderr log path and return

		else:
			pass  # return "bad request"


app = webapp2.WSGIApplication([
	(JOBS_LIST_CREATE_EXP, Jobs),
	(JOB_DESCRIBE_EXP, Jobs),
	(JOB_EDIT_EXP, Jobs),
	(JOB_CANCEL_EXP, Jobs),
	(JOB_RESTART_EXP, Jobs),
	(CONFIG_VIEW_INIT_EXP, Config),
	(CONFIG_EDIT_EXP, Config),
	(DATADISKS_LIST_CREATE_EXP, DataDisk),
	(DATADISK_DESCRIBE_DELETE_EXP, DataDisk),
	(LOG_STDOUT_EXP, Log),
	(LOG_STDERR_EXP, Log),
], debug=True)


def main():
	httpserver.serve(app, host='0.0.0.0', port='8080')


if __name__ == "__main__":
	main()
